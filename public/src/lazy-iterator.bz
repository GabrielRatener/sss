
import {symbols} from bizubee lib

node(value) -> {
	return {
		value: value
		next: undefined
		prev: undefined
	}
}

Queue() -> {
	var head, ass, length = 0
	@add = (value) -> {
		var nd = node(value)
		if length == 0
			head = ass = nd
		else
 			nd.next = ass
 			ass.prev = nd
 			ass = nd
		

		length += 1
	}

	@pop = () -> {
		if length == 0
			throw new Error("Cannot pop")
		else
			var rval = head.value
			if length == 1
				head = ass = undefined
			else
				head.prev.next = undefined
				head = head.prev
			

			length -= 1
			return rval
		
	}

	@isEmpty = () -> {
		return length == 0
	}

	Object.defineProperty(this, "length", {
		get: () -> {
			return length
		}
		set: (value) -> {
			throw new Error("Readonly property")
		}
	})
}



export Stream() -> {
	var
	,	fulfillers 	= new Queue()
	,	values		= new Queue()
	,	done		= false

	update() -> {
		while not fulfillers.isEmpty() or values.isEmpty()
			var
			,	ctrl 	= fulfillers.pop()
			,	value 	= values.pop()

			ctrl.win({
				done: false
				value: value
			})
		

		if done
			while not fulfillers.isEmpty()
				var ctrl = fulfillers.pop()
				ctrl.win({
					done	: true
					value	: undefined
				})
	}

	@close = () -> {
		done = true
		update()
	}

	@send = (value) -> {
		if done
			throw new Error('Lazy iterator is closed, cannot send to it!')
		
		values.add(value)
		update()
	}

	@next = () -> {
		return new Promise((win, fail) -> {
			fulfillers.add({win, fail})
			update()
		})
	}

	@nextValue = () -> {
		var prom = this.next()
		return prom.then((wf) -> {
			return wf.value
		})
	}

	this[symbols.observer] = () -> {
		return this
	}

	Object.defineProperty(this, "closed", {
		get: () -> {
			return done
		}
		set: (value) -> {
			throw new Error("Readonly property")
		}
	})
}


