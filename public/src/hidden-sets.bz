
import {combinations} from ./util

export hiddenSets(sudoku, n, collection = null) -> {
	if collection == null
		for group in sudoku.allCollections()
			hiddenSets(sudoku, n, group)
	else
		# find and clean hidden doubles, triples, ...
		const
		,	tried		= new Set()
		,	val2points 	= new Map()
		,	vals		= []

		# build map of values to list of points where they
		# occur in the given collection
		for pt in collection.iterate()
			const ptcode = sudoku.encode(pt)
			if sudoku.determined(pt)
				continue
			for val in sudoku.getPossibilities(pt)
				if not val2points.has(val)
					vals.push(val)
					val2points.set(val, new Set())

				val2points.get(val).add(ptcode)

		if not vals.length > n
			return

		# find each unique tuple of length n of missing values
		# then if the number of possible points that can contain
		# the missing values is also n, we remove other possibilities
		for combo in combinations(vals, n)
			const points = new Set()
			for val in combo
				for ptcode in val2points.get(val)
					points.add(ptcode)
			if points.size == n
				const comboSet = new Set(combo)
				for ptcode in points
					const pt = sudoku.decode(ptcode)
					if sudoku.determined(pt)
						continue
					for possible in sudoku.getPossibilities(pt)
						if comboSet.has(possible)
							continue
						sudoku.removePossibility(pt, possible)
}
